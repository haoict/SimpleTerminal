#include "font.h"

#include <SDL2/SDL.h>
#include <SDL2/SDL_ttf.h>

// font from https://github.com/nesbox/TIC-80
// Each character is 8 bytes (6 rows of pixels, plus 2 unused bytes)
// Format: 8x6 pixel grid, stored as bit patterns in bytes
static const unsigned char embedded_font[] = {
    // ASCII 0-31: Control characters (all empty)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0: NULL
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 1
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 2
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 3
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 4
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 5
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 6
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 7
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 8
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 9
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 10
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 11
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 12
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 13
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 14
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 15
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 16
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 17
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 18
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 19
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 20
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 21
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 22
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 23
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 24
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 25
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 26
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 27
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 28
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 29
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 30
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 31

    // ASCII 32-126: Printable characters
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 32: ' ' (space)
    0x30, 0x30, 0x30, 0x00, 0x30, 0x00, 0x00, 0x00,  // 33: '!'
    0x50, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 34: '"'
    0x50, 0xf8, 0x50, 0xf8, 0x50, 0x00, 0x00, 0x00,  // 35: '#'
    0x78, 0xa0, 0x70, 0x28, 0xf0, 0x00, 0x00, 0x00,  // 36: '$'
    0x88, 0x10, 0x20, 0x40, 0x88, 0x00, 0x00, 0x00,  // 37: '%'
    0x40, 0xa0, 0x68, 0x90, 0x68, 0x00, 0x00, 0x00,  // 38: '&'
    0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 39: '''
    0x20, 0x40, 0x40, 0x40, 0x20, 0x00, 0x00, 0x00,  // 40: '('
    0x40, 0x20, 0x20, 0x20, 0x40, 0x00, 0x00, 0x00,  // 41: ')'
    0x20, 0xa8, 0x70, 0xa8, 0x20, 0x00, 0x00, 0x00,  // 42: '*'
    0x00, 0x20, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,  // 43: '+'
    0x00, 0x00, 0x00, 0x60, 0x20, 0x40, 0x00, 0x00,  // 44: ','
    0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00,  // 45: '-'
    0x00, 0x00, 0x00, 0x00, 0x60, 0x60, 0x00, 0x00,  // 46: '.'
    0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00,  // 47: '/'

    // Numbers 0-9
    0x70, 0xc8, 0xc8, 0xc8, 0x70, 0x00, 0x00, 0x00,  // 48: '0'
    0x30, 0x70, 0x30, 0x30, 0x78, 0x00, 0x00, 0x00,  // 49: '1'
    0xf0, 0x18, 0x70, 0xc0, 0xf8, 0x00, 0x00, 0x00,  // 50: '2'
    0xf8, 0x18, 0x30, 0x98, 0x70, 0x00, 0x00, 0x00,  // 51: '3'
    0x30, 0x70, 0xd0, 0xf8, 0x10, 0x00, 0x00, 0x00,  // 52: '4'
    0xf8, 0xc0, 0xf0, 0x18, 0xf0, 0x00, 0x00, 0x00,  // 53: '5'
    0x70, 0xc0, 0xf0, 0xc8, 0x70, 0x00, 0x00, 0x00,  // 54: '6'
    0xf8, 0x18, 0x30, 0x60, 0xc0, 0x00, 0x00, 0x00,  // 55: '7'
    0x70, 0xc8, 0x70, 0xc8, 0x70, 0x00, 0x00, 0x00,  // 56: '8'
    0x70, 0xc8, 0x78, 0x08, 0x70, 0x00, 0x00, 0x00,  // 57: '9'

    // Punctuation
    0x60, 0x60, 0x00, 0x60, 0x60, 0x00, 0x00, 0x00,  // 58: ':'
    0x60, 0x60, 0x00, 0x60, 0x20, 0x40, 0x00, 0x00,  // 59: ';'
    0x10, 0x20, 0x40, 0x20, 0x10, 0x00, 0x00, 0x00,  // 60: '<'
    0x00, 0x00, 0x70, 0x00, 0x70, 0x00, 0x00, 0x00,  // 61: '='
    0x40, 0x20, 0x10, 0x20, 0x40, 0x00, 0x00, 0x00,  // 62: '>'
    0x78, 0x18, 0x30, 0x00, 0x30, 0x00, 0x00, 0x00,  // 63: '?'
    0x70, 0xa8, 0xb8, 0x80, 0x70, 0x00, 0x00, 0x00,  // 64: '@'

    // Uppercase letters A-Z
    0x70, 0xc8, 0xc8, 0xf8, 0xc8, 0x00, 0x00, 0x00,  // 65: 'A'
    0xf0, 0xc8, 0xf0, 0xc8, 0xf0, 0x00, 0x00, 0x00,  // 66: 'B'
    0x70, 0xc8, 0xc0, 0xc8, 0x70, 0x00, 0x00, 0x00,  // 67: 'C'
    0xf0, 0xc8, 0xc8, 0xc8, 0xf0, 0x00, 0x00, 0x00,  // 68: 'D'
    0xf8, 0xc0, 0xf0, 0xc0, 0xf8, 0x00, 0x00, 0x00,  // 69: 'E'
    0xf8, 0xc0, 0xf0, 0xc0, 0xc0, 0x00, 0x00, 0x00,  // 70: 'F'
    0x78, 0xc0, 0xd8, 0xc8, 0x78, 0x00, 0x00, 0x00,  // 71: 'G'
    0xc8, 0xc8, 0xf8, 0xc8, 0xc8, 0x00, 0x00, 0x00,  // 72: 'H'
    0x78, 0x30, 0x30, 0x30, 0x78, 0x00, 0x00, 0x00,  // 73: 'I'
    0xf8, 0x18, 0x18, 0xd8, 0x70, 0x00, 0x00, 0x00,  // 74: 'J'
    0xc8, 0xd0, 0xe0, 0xd0, 0xc8, 0x00, 0x00, 0x00,  // 75: 'K'
    0xc0, 0xc0, 0xc0, 0xc0, 0xf8, 0x00, 0x00, 0x00,  // 76: 'L'
    0xd8, 0xf8, 0xf8, 0xa8, 0x88, 0x00, 0x00, 0x00,  // 77: 'M'
    0xc8, 0xe8, 0xf8, 0xd8, 0xc8, 0x00, 0x00, 0x00,  // 78: 'N'
    0x70, 0xc8, 0xc8, 0xc8, 0x70, 0x00, 0x00, 0x00,  // 79: 'O'
    0xf0, 0xc8, 0xc8, 0xf0, 0xc0, 0x00, 0x00, 0x00,  // 80: 'P'
    0x70, 0xc8, 0xc8, 0xc8, 0x70, 0x08, 0x00, 0x00,  // 81: 'Q'
    0xf0, 0xc8, 0xc8, 0xf0, 0xc8, 0x00, 0x00, 0x00,  // 82: 'R'
    0x78, 0xe0, 0x70, 0x38, 0xf0, 0x00, 0x00, 0x00,  // 83: 'S'
    0x78, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00,  // 84: 'T'
    0xc8, 0xc8, 0xc8, 0xc8, 0x70, 0x00, 0x00, 0x00,  // 85: 'U'
    0xc8, 0xc8, 0xc8, 0x70, 0x20, 0x00, 0x00, 0x00,  // 86: 'V'
    0x88, 0xa8, 0xf8, 0xf8, 0xd8, 0x00, 0x00, 0x00,  // 87: 'W'
    0xc8, 0xc8, 0x70, 0xc8, 0xc8, 0x00, 0x00, 0x00,  // 88: 'X'
    0x68, 0x68, 0x78, 0x30, 0x30, 0x00, 0x00, 0x00,  // 89: 'Y'
    0xf8, 0x30, 0x60, 0xc0, 0xf8, 0x00, 0x00, 0x00,  // 90: 'Z'

    // More punctuation and symbols
    0x60, 0x40, 0x40, 0x40, 0x60, 0x00, 0x00, 0x00,  // 91: '['
    0x80, 0x40, 0x20, 0x10, 0x08, 0x00, 0x00, 0x00,  // 92: '\'
    0x60, 0x20, 0x20, 0x20, 0x60, 0x00, 0x00, 0x00,  // 93: ']'
    0x20, 0x50, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00,  // 94: '^'
    0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00,  // 95: '_'
    0x40, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 96: '`'

    // Lowercase letters a-z
    0x00, 0x78, 0x98, 0x98, 0x78, 0x00, 0x00, 0x00,  // 97: 'a'
    0xc0, 0xf0, 0xc8, 0xc8, 0xf0, 0x00, 0x00, 0x00,  // 98: 'b'
    0x00, 0x78, 0xe0, 0xe0, 0x78, 0x00, 0x00, 0x00,  // 99: 'c'
    0x18, 0x78, 0x98, 0x98, 0x78, 0x00, 0x00, 0x00,  // 100: 'd'
    0x00, 0x70, 0xd8, 0xe0, 0x70, 0x00, 0x00, 0x00,  // 101: 'e'
    0x38, 0x60, 0xf8, 0x60, 0x60, 0x00, 0x00, 0x00,  // 102: 'f'
    0x00, 0x70, 0x98, 0xf8, 0x18, 0x70, 0x00, 0x00,  // 103: 'g'
    0xc0, 0xf0, 0xc8, 0xc8, 0xc8, 0x00, 0x00, 0x00,  // 104: 'h'
    0x30, 0x00, 0x70, 0x30, 0x78, 0x00, 0x00, 0x00,  // 105: 'i'
    0x18, 0x00, 0x18, 0x18, 0x98, 0x70, 0x00, 0x00,  // 106: 'j'
    0xc0, 0xc8, 0xf0, 0xc8, 0xc8, 0x00, 0x00, 0x00,  // 107: 'k'
    0x60, 0x60, 0x60, 0x60, 0x38, 0x00, 0x00, 0x00,  // 108: 'l'
    0x00, 0xd0, 0xf8, 0xa8, 0xa8, 0x00, 0x00, 0x00,  // 109: 'm'
    0x00, 0xf0, 0xc8, 0xc8, 0xc8, 0x00, 0x00, 0x00,  // 110: 'n'
    0x00, 0x70, 0xc8, 0xc8, 0x70, 0x00, 0x00, 0x00,  // 111: 'o'
    0x00, 0xf0, 0xc8, 0xc8, 0xf0, 0xc0, 0x00, 0x00,  // 112: 'p'
    0x00, 0x78, 0x98, 0x98, 0x78, 0x18, 0x00, 0x00,  // 113: 'q'
    0x00, 0xf0, 0xc8, 0xc0, 0xc0, 0x00, 0x00, 0x00,  // 114: 'r'
    0x00, 0x78, 0xe0, 0x38, 0xf0, 0x00, 0x00, 0x00,  // 115: 's'
    0x60, 0xf8, 0x60, 0x60, 0x38, 0x00, 0x00, 0x00,  // 116: 't'
    0x00, 0x98, 0x98, 0x98, 0x78, 0x00, 0x00, 0x00,  // 117: 'u'
    0x00, 0xc8, 0xc8, 0xd0, 0xe0, 0x00, 0x00, 0x00,  // 118: 'v'
    0x00, 0x88, 0xa8, 0xf8, 0xd8, 0x00, 0x00, 0x00,  // 119: 'w'
    0x00, 0xd8, 0x70, 0x70, 0xd8, 0x00, 0x00, 0x00,  // 120: 'x'
    0x00, 0x98, 0x98, 0x78, 0x18, 0x70, 0x00, 0x00,  // 121: 'y'
    0x00, 0xf8, 0x30, 0x60, 0xf8, 0x00, 0x00, 0x00,  // 122: 'z'

    // Final punctuation
    0x30, 0x20, 0x60, 0x20, 0x30, 0x00, 0x00, 0x00,  // 123: '{'
    0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00,  // 124: '|'
    0x60, 0x20, 0x30, 0x20, 0x60, 0x00, 0x00, 0x00,  // 125: '}'
    0x00, 0x28, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00,  // 126: '~'
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00   // 127: DEL
};

static int embeded_font_char_width = 6;
static int embeded_font_char_height = 8;

/* TTF Font globals */
static TTF_Font *ttf_font = NULL;
static int ttf_char_width = 6;   // fallback to bitmap size
static int ttf_char_height = 8;  // fallback to bitmap size
static int ttf_font_shade = 0;

/* TTF font */
int init_ttf_font(const char *font_path, int font_size, int shade) {
    if (TTF_Init() == -1) {
        fprintf(stderr, "TTF_Init failed: %s\n", TTF_GetError());
        return 0;
    }

    ttf_font = TTF_OpenFont(font_path, font_size);
    if (!ttf_font) {
        fprintf(stderr, "Failed to load font '%s': %s\n", font_path, TTF_GetError());
        TTF_Quit();
        return 0;
    }

    // Get font metrics
    TTF_SizeText(ttf_font, "M", &ttf_char_width, &ttf_char_height);
    ttf_font_shade = shade;

    fprintf(stderr, "TTF font loaded: %s (size: %d, char: %dx%d), shaded: %d\n", font_path, font_size, ttf_char_width, ttf_char_height, ttf_font_shade);

    return 1;
}

void cleanup_ttf_font(void) {
    if (ttf_font) {
        TTF_CloseFont(ttf_font);
        ttf_font = NULL;
        TTF_Quit();
    }
}

int is_ttf_loaded(void) { return ttf_font != NULL; }

int get_ttf_char_width(void) { return ttf_char_width; }

int get_ttf_char_height(void) { return ttf_char_height; }

void draw_string_ttf(SDL_Surface *surface, const char *text, int x, int y, SDL_Color fg, SDL_Color bg) {
    if (!ttf_font || !surface || !text) {
        fprintf(stderr, "Invalid parameters for draw_string_ttf\n");
        return;
    }
    if (strlen(text) == 0) {  // Nothing to draw
        return;
    }

    SDL_Surface *text_surface;
    if (ttf_font_shade == 2) {  // highest quality
        text_surface = TTF_RenderText_Shaded(ttf_font, text, fg, bg);
    } else if (ttf_font_shade == 1) {  // medium quality
        text_surface = TTF_RenderText_Blended(ttf_font, text, fg);
    } else {
        text_surface = TTF_RenderText_Solid(ttf_font, text, fg);
    }

    if (!text_surface) {
        fprintf(stderr, "TTF_RenderText_Shaded %s failed: %s\n", text, TTF_GetError());
        return;
    }

    SDL_Rect dest = {x, y, text_surface->w, text_surface->h};
    SDL_BlitSurface(text_surface, NULL, surface, &dest);
    SDL_FreeSurface(text_surface);
}

void draw_string_ttf_with_linebreak(SDL_Surface *surface, const char *text, int x, int y, SDL_Color fg, SDL_Color bg) {
    if (!ttf_font || !surface || !text) return;

    int line_height = get_ttf_char_height();
    const char *line_start = text;
    int cur_y = y;
    while (*line_start) {
        // Find next line break
        const char *line_end = line_start;
        while (*line_end && *line_end != '\n') line_end++;

        // Copy line to buffer
        size_t len = line_end - line_start;
        char line_buf[1024];
        if (len >= sizeof(line_buf)) len = sizeof(line_buf) - 1;
        memcpy(line_buf, line_start, len);
        line_buf[len] = '\0';

        if (len > 0) {
            draw_string_ttf(surface, line_buf, x, cur_y, fg, bg);
        }

        if (*line_end == '\n') {
            cur_y += line_height;
            line_start = line_end + 1;
        } else {
            break;
        }
    }
}

/* Embedded Bitmap font */
void draw_char(SDL_Surface *surface, unsigned char symbol, int x, int y, unsigned short color) {
    x += (8 - 1) * 1;
    int flip = 0;
    if (symbol > 127) {
        flip = 1;
        symbol -= 128;
    }
    const unsigned char *ptr = embedded_font + symbol * 8;
    for (int i = 0, ys = 0; i < 6; i++, ptr++, ys += 1)
        for (int col = 8 - 6, xs = x - col; col < 8; col++, xs -= 1)
            if ((*ptr & 1 << col) && y + ys < surface->h && xs < surface->w) ((unsigned short *)surface->pixels)[(y + flip * 4 + (1 - 2 * flip) * ys) * (surface->pitch >> 1) + xs] = color;
}

void draw_string(SDL_Surface *surface, const char *text, int orig_x, int orig_y, unsigned short color) {
    int x = orig_x, y = orig_y;
    while (*text) {
        if (*text == '\n') {
            x = orig_x;
            y += 8;
        } else {
            draw_char(surface, *text, x, y, color);
            x += 6;
        }
        text++;
    }
}

int get_embeded_font_char_width(void) { return embeded_font_char_width; }

int get_embeded_font_char_height(void) { return embeded_font_char_height; }